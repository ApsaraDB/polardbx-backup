diff a/storage/innobase/srv/srv0srv.cc b/storage/innobase/srv/srv0srv.cc	(rejected hunks)
@@ -111,6 +111,7 @@ bool srv_upgrade_old_undo_found = false;
 
 
 #include "lizard0cleanout.h"
+#include "lizard0sys.h"
 
 /* The following is the maximum allowed duration of a lock wait. */
 ulong srv_fatal_semaphore_wait_threshold = 600;
@@ -1648,6 +1649,37 @@ void srv_export_innodb_status(void) {
 //    export_vars.innodb_purge_view_trx_id_age =
 //        (ulint)(max_trx_no - low_limit_no + 1);
 //  }
+
+  rw_lock_s_lock(&purge_sys->latch);
+  scn_t done_trx_scn = purge_sys->done.scn;
+
+  /* Purge always deals with transaction end points represented by
+  transaction number. We are allowed to purge transactions with number
+  below the low limit. */
+  lizard::Vision oldest_vision;
+  lizard::trx_clone_oldest_vision(&oldest_vision);
+  scn_t low_limit_scn = oldest_vision.snapshot_scn();
+
+  rw_lock_s_unlock(&purge_sys->latch);
+
+  /* Maximum transaction number added to history list for purge. */
+  scn_t max_trx_scn = lizard::lizard_sys->min_safe_scn.load();
+
+  if (done_trx_scn == 0 || max_trx_scn < done_trx_scn) {
+    export_vars.innodb_purge_trx_scn_age = 0;
+  } else {
+    /* Add 1 as done_trx_no always points to the next transaction ID. */
+    export_vars.innodb_purge_trx_scn_age = (ulint)(max_trx_scn - done_trx_scn + 1);
+  }
+
+  if (low_limit_scn == 0 || max_trx_scn < low_limit_scn) {
+    export_vars.innodb_purge_view_trx_scn_age = 0;
+  } else {
+    /* Add 1 as low_limit_scn always points to the next transaction ID. */
+    export_vars.innodb_purge_view_trx_scn_age =
+        (ulint)(max_trx_scn - low_limit_scn + 1);
+  }
+
 #endif /* UNIV_DEBUG */
 
   mutex_exit(&srv_innodb_monitor_mutex);
